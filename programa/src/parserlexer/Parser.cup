package parserlexer;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import utils.SymbolTable;

action code 
{: 
    public SymbolTable symbolTable = new SymbolTable(); 
:}

parser code
{:
    private Symbol s;
  
    //Lista de errores controlados
    private List<String> errorList = new ArrayList<>();
    
    // Agrega errores controlados a la lista
    public void logError(Symbol s) {
        String error = "Error cerca de Linea: " + (s.right + 1) + " Columna: " + (s.left + 1) + ", Texto: \"" + s.value + "\"";
        errorList.add(error);
    }

    // Obtiene la lista de errores controlados
    public List<String> getErrorList() {
        return errorList;
    }

    // Gestiona errores recuperables -error-
    public void syntax_error(Symbol s){
        this.s = s;
        logError(s);
    }

    // Gestiona errores no recuperables
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        String error = "\nError no recuperable:\n No se encontró final de sentencia (finregalo), \n o no se encontró final de bloque (cierracuento) \n o se determinó un error desconocido ";
        errorList.add(error);
    }

    // Método para obtener el Symbol donde se generó el error.
    public Symbol getS(){
        return this.s;
    }

    //Método para salida por consolda
    public void print(String prodName, Symbol s){
         String salida = "Encontrado " +prodName+ " : cerca de Linea: " + (s.right + 1) + " Columna: " + (s.left + 1) + ", Texto: \"" + s.value + "\"";
         System.out.println(salida); 
    }
:};

/* TERMINALS */

/* ---------- General ---------- */
terminal                        Main, Identifier;

/* ---------- Literals ---------- */
terminal                        IntegerLiteral, FloatLiteral, BoolLiteral, CharacterLiteral, StringLiteral;

/* ---------- Types ---------- */
terminal                        Integer, Float, Bool, Char, String;

/* ---------- Arrays ---------- */
terminal                        BracketOpening, BracketClosure;

/* ---------- Operators ---------- */
// Assignment sign
terminal                        AssignmentSign;

// Parenthesis
terminal                        ParenthesisOpening, ParenthesisClosure;

// Binary Arithmetic Operators
terminal                        Sum, Subtraction, Division, Multiplication, Module, Power;

// Unary Arithmetic Operators
terminal                        Increment, Decrement;

//Negative operator
terminal                        Negative;

// Relational Operators
terminal                        Less, LessEqual, Greater, GreaterEqual, Equal, NotEqual;

// Logical Operators
terminal                        Conjunction, Disjunction, Negation;

/* ---------- Blocks ---------- */
terminal                        BlockOpening, BlockClosure, EndSentence;                    

/* ---------- Control Structures ---------- */
terminal                        If, Else, While, For, Switch, Case, Default, Break, Return, Colon, Comma;

/* ---------- IO Operators ---------- */
terminal                        Print, Read;

/* ---------- NON TERMINALES ---------- */

non terminal PROGRAM, VARIABLE_TYPE, VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT;
non terminal NEGATIVE_OPERATOR, PARAMETER_DECLARATION, PARAMETER_DECLARATION_LIST, PARAMETER_DECLARATION_OPTION; 
non terminal FUNCTION_DECLARATION,FUNCTION_CALL, FUNCTION_CALL_PARAMETER, FUNCTION_CALL_PARAMETER_LIST, FUNCTION_CALL_PARAMETER_OPTION, LITERALS ;
non terminal FUNCTION_DECLARATION_BODY, EXPRESSION, BINARY_ARITHMETIC_OPERATOR, ARITHMETIC_EXPRESSION, SIMPLE_EXPRESSION;
non terminal FUNCTION_BODY_ELEMENT, NEGATIVE_LITERAL, UNARY_ARITHMETIC_EXPRESSION;
non terminal CONTROL_STRUCTURE, IF_STRUCTURE, WHILE_STRUCTURE, FOR_STRUCTURE, SWITCH_STRUCTURE,CASES, CASE, RETURN_STATEMENT, BREAK_STATEMENT;
non terminal PRINT_STATEMENT, READ_STATEMENT, RELATIONAL_EXPRESSION, LOGICAL_EXPRESSION, EXPRESSION_LIST, FUNCTION_NAME, ARRAY_DECLARATION,ARRAY_USE;
non terminal ARRAY_ELEMENTS, LITERAL_LIST, ELSE_STRUCTURE, ELSE_IF_STRUCTURE, IF_ELSE_STRUCTURE_TYPE, UPDATE_EXPRESSION, RELATIONAL_OPERATOR;
non terminal INIT_FOR_STRUCTURE, SWITCH_EXPRESSION, CASE_LABEL, FUNCTION_CALL_EXPRESSION;
non terminal FIND_ERROR_WITH_END_SENTENCE, FIND_ERROR_WITH_BLOCK_CLOSURE;

/* ---------- Precedences ---------- */

precedence left Disjunction;
precedence left Conjunction;
precedence right Negation;
precedence left Less, LessEqual, Greater, GreaterEqual, Equal, NotEqual;
precedence left Sum, Subtraction;
precedence left Multiplication, Division, Module; 
precedence right Power;
precedence right AssignmentSign; 

// Declaración del non terminal inicial
start with PROGRAM;

// Definición del non terminal inicial
PROGRAM ::= /* Vacío */ 
          | PROGRAM FUNCTION_DECLARATION 
          | PROGRAM FIND_ERROR_WITH_BLOCK_CLOSURE;

FUNCTION_DECLARATION ::= VARIABLE_TYPE:type FUNCTION_NAME:id 
                         ParenthesisOpening PARAMETER_DECLARATION_OPTION:params ParenthesisClosure 
                         BlockOpening FUNCTION_DECLARATION_BODY:body BlockClosure 
                         {:
                            symbolTable.addFunction(id.toString(), type.toString(), params.toString());
                            System.out.println("La función " + id.toString() + " ha sido agregada a la tabla de símbolos.");
                            symbolTable.printFunctionSymbols();
                         :};

VARIABLE_TYPE ::= Integer {: RESULT = "Integer"; :}
                | Float   {: RESULT = "Float";   :}
                | String  {: RESULT = "String";  :}
                | Bool    {: RESULT = "Bool";    :}
                | Char    {: RESULT = "Char";    :};

FUNCTION_NAME ::= Identifier:id {: RESULT = id.toString(); :}
                | Main          {: RESULT = "Main";        :};

PARAMETER_DECLARATION ::= VARIABLE_TYPE:type Identifier:id 
                          {: RESULT = type.toString() + " " + id.toString(); :};

PARAMETER_DECLARATION_LIST ::= PARAMETER_DECLARATION:param 
                               {: RESULT = param; :}
                             | PARAMETER_DECLARATION:param Comma PARAMETER_DECLARATION_LIST:list 
                               {: RESULT = param + ", " + list; :};

PARAMETER_DECLARATION_OPTION ::= /* Vacío */ 
                                 {: RESULT = ""; :}
                               | PARAMETER_DECLARATION_LIST:params 
                                 {: RESULT = params; :};


FUNCTION_DECLARATION_BODY ::= FUNCTION_BODY_ELEMENT 
                              {: RESULT = "Cuerpo de la funcion simple"; :} 
                            | FUNCTION_DECLARATION_BODY FUNCTION_BODY_ELEMENT
                              {: RESULT = "Cuerpo de la funcion compuesto"; :};

FUNCTION_BODY_ELEMENT ::= VARIABLE_DECLARATION 
                        | VARIABLE_ASSIGNMENT 
                        | FUNCTION_CALL_EXPRESSION 
                        | CONTROL_STRUCTURE
                        | PRINT_STATEMENT 
                        | READ_STATEMENT
                        | RETURN_STATEMENT
                        | BREAK_STATEMENT
                        ;

VARIABLE_DECLARATION ::= VARIABLE_TYPE:type Identifier:id EndSentence
                        {: 
                            symbolTable.addVariable(id.toString(), type.toString(), "local");
                            System.out.println("Variable " + id.toString() + " de tipo " + type.toString() + " ha sido declarada.");
                        :}
                       | VARIABLE_TYPE:type Identifier:id AssignmentSign EXPRESSION EndSentence
                        {: 
                            symbolTable.addVariable(id.toString(), type.toString(), "local");
                            System.out.println("Variable " + id.toString() + " de tipo " + type.toString() + " ha sido declarada.");
                        :}
                       | ARRAY_DECLARATION EndSentence 
                       | ARRAY_DECLARATION AssignmentSign ARRAY_ELEMENTS EndSentence
                       | VARIABLE_DECLARATION FIND_ERROR_WITH_END_SENTENCE
                       ;

ARRAY_ELEMENTS ::= BlockOpening LITERAL_LIST:list BlockClosure
                 {: 
                     System.out.println("Elementos del array: " + list.toString());
                 :}
                 | ARRAY_ELEMENTS FIND_ERROR_WITH_BLOCK_CLOSURE
                 {: 
                     System.out.println("Error en los elementos del array.");
                 :};

ARRAY_DECLARATION ::= VARIABLE_TYPE:type Identifier:id BracketOpening BracketClosure 
                    {: 
                        symbolTable.addVariable(id.toString(), type.toString() + "[]", "local");
                        System.out.println("Array " + id.toString() + " de tipo " + type.toString() + " declarado.");
                    :}
                    | VARIABLE_TYPE:type Identifier:id BracketOpening Integer:size BracketClosure 
                    {: 
                        symbolTable.addVariable(id.toString(), type.toString() + "[" + size + "]", "local");
                        System.out.println("Array " + id.toString() + " con tamaño " + size + " declarado.");
                    :}
                    | VARIABLE_TYPE:type Identifier:id BracketOpening Identifier:sizeId BracketClosure 
                    {: 
                        symbolTable.addVariable(id.toString(), type.toString() + "[]", "local");
                        System.out.println("Array " + id.toString() + " de tamaño variable " + sizeId + " declarado.");
                        symbolTable.printVariableSymbols();
                    :};

ARRAY_USE ::= Identifier BracketOpening Integer BracketClosure 
            | Identifier BracketOpening Identifier BracketClosure
            ;

LITERAL_LIST ::= LITERALS
               | LITERAL_LIST Comma LITERALS
               ;

LITERALS ::= IntegerLiteral 
           | FloatLiteral 
           | BoolLiteral 
           | CharacterLiteral 
           | StringLiteral;

PRINT_STATEMENT ::= Print ParenthesisOpening EXPRESSION ParenthesisClosure EndSentence
                  | PRINT_STATEMENT FIND_ERROR_WITH_END_SENTENCE
                  ;

READ_STATEMENT ::= Read ParenthesisOpening Identifier ParenthesisClosure EndSentence
                 | READ_STATEMENT FIND_ERROR_WITH_END_SENTENCE
                 ;

BINARY_ARITHMETIC_OPERATOR ::= Sum 
                             | Subtraction 
                             | Multiplication 
                             | Division 
                             | Module 
                             | Power;

NEGATIVE_OPERATOR ::= Negative; 

FUNCTION_CALL_PARAMETER ::= SIMPLE_EXPRESSION;

FUNCTION_CALL_PARAMETER_LIST ::= FUNCTION_CALL_PARAMETER 
                               | FUNCTION_CALL_PARAMETER Comma FUNCTION_CALL_PARAMETER_LIST;

FUNCTION_CALL_PARAMETER_OPTION ::= /* Vacío */ 
                                 | FUNCTION_CALL_PARAMETER_LIST;

FUNCTION_CALL ::= FUNCTION_NAME ParenthesisOpening FUNCTION_CALL_PARAMETER_OPTION  ParenthesisClosure;

FUNCTION_CALL_EXPRESSION ::= FUNCTION_CALL EndSentence
                           | FUNCTION_CALL_EXPRESSION FIND_ERROR_WITH_END_SENTENCE
                           ;

NEGATIVE_LITERAL ::= NEGATIVE_OPERATOR IntegerLiteral 
                   | NEGATIVE_OPERATOR FloatLiteral;

UNARY_ARITHMETIC_EXPRESSION ::= Identifier Increment 
                              | Identifier Decrement;


EXPRESSION ::= NEGATIVE_LITERAL 
             | ARITHMETIC_EXPRESSION
             | LOGICAL_EXPRESSION             
             ;


SIMPLE_EXPRESSION ::= Identifier                     
                    | LITERALS
                    | ARRAY_USE
                    | FUNCTION_CALL
                    | UNARY_ARITHMETIC_EXPRESSION
                    | ParenthesisOpening EXPRESSION ParenthesisClosure
                    ;

ARITHMETIC_EXPRESSION ::= SIMPLE_EXPRESSION
                        | ARITHMETIC_EXPRESSION BINARY_ARITHMETIC_OPERATOR ARITHMETIC_EXPRESSION
                        ;

RELATIONAL_OPERATOR ::= Less 
                      | LessEqual 
                      | Greater
                      | GreaterEqual
                      | Equal
                      | NotEqual
                      ;

RELATIONAL_EXPRESSION ::= ARITHMETIC_EXPRESSION RELATIONAL_OPERATOR ARITHMETIC_EXPRESSION;

LOGICAL_EXPRESSION ::= RELATIONAL_EXPRESSION
                     | Negation LOGICAL_EXPRESSION
                     | LOGICAL_EXPRESSION Conjunction RELATIONAL_EXPRESSION 
                     | LOGICAL_EXPRESSION Disjunction RELATIONAL_EXPRESSION
                     | LOGICAL_EXPRESSION Conjunction ARITHMETIC_EXPRESSION 
                     | LOGICAL_EXPRESSION Disjunction ARITHMETIC_EXPRESSION
                     ;

EXPRESSION_LIST ::= EXPRESSION 
                  | EXPRESSION Comma EXPRESSION_LIST;

VARIABLE_ASSIGNMENT ::= Identifier AssignmentSign EXPRESSION EndSentence
                      | UNARY_ARITHMETIC_EXPRESSION EndSentence
                      | Identifier AssignmentSign ARRAY_ELEMENTS EndSentence //Para asignación de arreglo de elementos
                      | ARRAY_USE AssignmentSign EXPRESSION EndSentence //Para asignación de un elemento en el arreglo
                      | VARIABLE_ASSIGNMENT FIND_ERROR_WITH_END_SENTENCE
                      ;

CONTROL_STRUCTURE ::= IF_ELSE_STRUCTURE_TYPE 
                    | WHILE_STRUCTURE
                    | FOR_STRUCTURE
                    | SWITCH_STRUCTURE
                    | CONTROL_STRUCTURE FIND_ERROR_WITH_BLOCK_CLOSURE
                    ;

IF_STRUCTURE ::= If ParenthesisOpening LOGICAL_EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure ;

ELSE_STRUCTURE ::= Else BlockOpening FUNCTION_DECLARATION_BODY BlockClosure ;

ELSE_IF_STRUCTURE ::= Else If ParenthesisOpening LOGICAL_EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure 
                    | ELSE_IF_STRUCTURE ELSE_STRUCTURE
                    ;

IF_ELSE_STRUCTURE_TYPE ::= IF_STRUCTURE
                         | IF_STRUCTURE ELSE_STRUCTURE
                         | IF_STRUCTURE ELSE_IF_STRUCTURE
                         ;

WHILE_STRUCTURE ::= While ParenthesisOpening LOGICAL_EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure;

FOR_STRUCTURE ::= For ParenthesisOpening INIT_FOR_STRUCTURE LOGICAL_EXPRESSION EndSentence UPDATE_EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure;

INIT_FOR_STRUCTURE ::= VARIABLE_DECLARATION
                     | VARIABLE_ASSIGNMENT
                     ;

UPDATE_EXPRESSION ::= UNARY_ARITHMETIC_EXPRESSION
                    | Identifier AssignmentSign EXPRESSION
                    ;

SWITCH_STRUCTURE ::= Switch ParenthesisOpening SWITCH_EXPRESSION ParenthesisClosure BlockOpening CASES  BlockClosure;

CASES ::= CASE 
        | CASE CASES;

CASE ::= Case CASE_LABEL Colon FUNCTION_DECLARATION_BODY
       | Default Colon FUNCTION_DECLARATION_BODY
       ;

SWITCH_EXPRESSION ::= Identifier                      
                    | Integer 
                    | Char 
                    | ARRAY_USE
                    | FUNCTION_CALL
                    | UNARY_ARITHMETIC_EXPRESSION
                    | ParenthesisOpening EXPRESSION ParenthesisClosure
                    ;

CASE_LABEL ::= Identifier                      
             | IntegerLiteral 
             | CharacterLiteral
             ;

RETURN_STATEMENT ::= Return EndSentence
                   | Return EXPRESSION EndSentence
                   | RETURN_STATEMENT FIND_ERROR_WITH_END_SENTENCE
                   ;

BREAK_STATEMENT ::= Break EndSentence
                  | BREAK_STATEMENT FIND_ERROR_WITH_END_SENTENCE
                  ;
FIND_ERROR_WITH_END_SENTENCE ::= error EndSentence {:Symbol s = (Symbol)CUP$Parser$stack.peek(); parser.print("EndSentence",s); :};
FIND_ERROR_WITH_BLOCK_CLOSURE ::= error BlockClosure {:Symbol s = (Symbol)CUP$Parser$stack.peek(); parser.print("BlockClosure",s); :};
