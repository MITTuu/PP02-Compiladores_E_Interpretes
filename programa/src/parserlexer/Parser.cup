package parserlexer;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;

parser code
{:
    private Symbol s;
    
    //Lista de errores controlados
    private List<String> errorList = new ArrayList<>();
    

    // Agrega errores controlados a la lista
    public void logError(Symbol s) {
        String error = "Error cerca de Linea: " + (s.right + 1) + " Columna: " + (s.left + 1) + ", Texto: \"" + s.value + "\"";
        errorList.add(error);
    }

    // Obtiene la lista de errores controlados
    public List<String> getErrorList() {
        return errorList;
    }

    // Gestiona errores recuperables -error-
    public void syntax_error(Symbol s){
        this.s = s;
        logError(s);
    }

    // Gestiona errores no recuperables
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        String error = "\nError no recuperable:\n No se encontró final de sentencia (finregalo), \n o no se encontró final de bloque (cierracuento) \n o se determinó un error desconocido ";
        errorList.add(error);
    }

    // Método para obtener el Symbol donde se generó el error.
    public Symbol getS(){
        return this.s;
    }

    //Método para salida por consolda
    public void print(String prodName, Symbol s){
         String salida = "Encontrado " +prodName+ " : cerca de Linea: " + (s.right + 1) + " Columna: " + (s.left + 1) + ", Texto: \"" + s.value + "\"";
         System.out.println(salida); 
    }
:};

/* TERMINALS */

/* ---------- General ---------- */
terminal                        Main, Identifier, Error;

/* ---------- Literals ---------- */
terminal                        IntegerLiteral, FloatLiteral, BoolLiteral, CharacterLiteral, StringLiteral;

/* ---------- Types ---------- */
terminal                        Integer, Float, Bool, Char, String;

/* ---------- Arrays ---------- */
terminal                        BracketOpening, BracketClosure;

/* ---------- Operators ---------- */
// Assignment sign
terminal                        AssignmentSign;

// Parenthesis
terminal                        ParenthesisOpening, ParenthesisClosure;

// Binary Arithmetic Operators
terminal                        Sum, Subtraction, Division, Multiplication, Module, Power;

// Unary Arithmetic Operators
terminal                        Increment, Decrement;

//Negative operator
terminal                        Negative;

// Relational Operators
terminal                        Less, LessEqual, Greater, GreaterEqual, Equal, NotEqual;

// Logical Operators
terminal                        Conjunction, Disjunction, Negation;

/* ---------- Blocks ---------- */
terminal                        BlockOpening, BlockClosure, EndSentence;                    

/* ---------- Control Structures ---------- */
terminal                        If, Else, While, For, Switch, Case, Default, Break, Return, Colon, Comma;

/* ---------- IO Operators ---------- */
terminal                        Print, Read;

/* ---------- NON TERMINALES ---------- */

non terminal PROGRAM, VARIABLE_TYPE, VARIABLE_DECLARATION, VARIABLE_ASSIGNMENT;
non terminal NEGATIVE_OPERATOR, PARAMETER_DECLARATION, PARAMETER_DECLARATION_LIST, PARAMETER_DECLARATION_OPTION; 
non terminal FUNCTION_DECLARATION,FUNCTION_CALL, FUNCTION_CALL_PARAMETER, FUNCTION_CALL_PARAMETER_LIST, FUNCTION_CALL_PARAMETER_OPTION, LITERALS ;
non terminal FUNCTION_DECLARATION_BODY, EXPRESSION, BINARY_ARITHMETIC_OPERATOR, ARITHMETIC_EXPRESSION, SIMPLE_EXPRESSION;
non terminal FUNCTION_BODY_ELEMENT, NEGATIVE_LITERAL, UNARY_ARITHMETIC_EXPRESSION;
non terminal CONTROL_STRUCTURE, IF_STRUCTURE, WHILE_STRUCTURE, FOR_STRUCTURE, SWITCH_STRUCTURE,CASES, CASE, RETURN_STATEMENT, BREAK_STATEMENT;

// Declaración del non terminal inicial
start with PROGRAM;

// Definición del non terminal inicial
PROGRAM ::=
        /* Vacío */ |
        PROGRAM FUNCTION_DECLARATION |
        PROGRAM error EndSentence {:Symbol s = (Symbol)CUP$Parser$stack.peek(); parser.print("EndSentence",s); :} |
        PROGRAM error BlockClosure {:Symbol s = (Symbol)CUP$Parser$stack.peek(); parser.print("BlockClosure",s); :}
        ;

FUNCTION_DECLARATION ::= VARIABLE_TYPE Identifier ParenthesisOpening PARAMETER_DECLARATION_OPTION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure;


FUNCTION_DECLARATION_BODY ::= 
                    FUNCTION_BODY_ELEMENT |
                    FUNCTION_DECLARATION_BODY FUNCTION_BODY_ELEMENT |
                    FUNCTION_DECLARATION_BODY error EndSentence {:Symbol s = (Symbol)CUP$Parser$stack.peek(); parser.print("EndSentence",s); :}
                    ;

FUNCTION_BODY_ELEMENT ::=
                        VARIABLE_DECLARATION |
                        VARIABLE_ASSIGNMENT |
                        FUNCTION_CALL |
                        CONTROL_STRUCTURE
                        ;

VARIABLE_TYPE ::= Integer | Float | String | Bool | Char ;


BINARY_ARITHMETIC_OPERATOR ::= Sum | Subtraction | Multiplication | Division |  Module | Power;

NEGATIVE_OPERATOR ::= Negative; 

LITERALS ::= IntegerLiteral | FloatLiteral | BoolLiteral | CharacterLiteral | StringLiteral ;

FUNCTION_CALL_PARAMETER ::= 
                            Identifier |
                            LITERALS
                            ;

FUNCTION_CALL_PARAMETER_LIST ::= 
                            FUNCTION_CALL_PARAMETER |
                            FUNCTION_CALL_PARAMETER Comma FUNCTION_CALL_PARAMETER_LIST 
                            ;

FUNCTION_CALL_PARAMETER_OPTION ::=  
                                /* Vacío */ |
                                FUNCTION_CALL_PARAMETER_LIST
                                ;

FUNCTION_CALL ::= Identifier ParenthesisOpening FUNCTION_CALL_PARAMETER_OPTION  ParenthesisClosure EndSentence;

PARAMETER_DECLARATION::= VARIABLE_TYPE Identifier;

PARAMETER_DECLARATION_LIST ::=  
                    PARAMETER_DECLARATION |
                    PARAMETER_DECLARATION Comma PARAMETER_DECLARATION_LIST 
                    ;

PARAMETER_DECLARATION_OPTION ::= 
                    /* Vacío */ |
                    PARAMETER_DECLARATION_LIST
                    ;

NEGATIVE_LITERAL ::= 
                    NEGATIVE_OPERATOR IntegerLiteral | 
                    NEGATIVE_OPERATOR FloatLiteral
                    ;

UNARY_ARITHMETIC_EXPRESSION ::= 
                                Identifier Increment |
                                Identifier Decrement 
                                ;

SIMPLE_EXPRESSION ::=                      
                    Identifier |
                    LITERALS |
                    FUNCTION_CALL 
                    ;

ARITHMETIC_EXPRESSION ::= SIMPLE_EXPRESSION BINARY_ARITHMETIC_OPERATOR EXPRESSION;

EXPRESSION ::= 
            SIMPLE_EXPRESSION | 
            ARITHMETIC_EXPRESSION |
            NEGATIVE_LITERAL |
            UNARY_ARITHMETIC_EXPRESSION
            ;

VARIABLE_DECLARATION ::= VARIABLE_TYPE Identifier EndSentence |
                         VARIABLE_TYPE Identifier AssignmentSign EXPRESSION EndSentence
                        ;

VARIABLE_ASSIGNMENT ::= Identifier AssignmentSign EXPRESSION EndSentence;

CONTROL_STRUCTURE ::= IF_STRUCTURE 
                    | WHILE_STRUCTURE
                    | FOR_STRUCTURE
                    | SWITCH_STRUCTURE
                    | RETURN_STATEMENT
                    | BREAK_STATEMENT;

IF_STRUCTURE ::= If ParenthesisOpening EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure
               | If ParenthesisOpening EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure Else BlockOpening FUNCTION_DECLARATION_BODY BlockClosure;

WHILE_STRUCTURE ::= While ParenthesisOpening EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure;

FOR_STRUCTURE ::= For ParenthesisOpening VARIABLE_DECLARATION EndSentence EXPRESSION EndSentence VARIABLE_ASSIGNMENT ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure;

SWITCH_STRUCTURE ::= Switch ParenthesisOpening EXPRESSION ParenthesisClosure BlockOpening CASES Default Colon FUNCTION_DECLARATION_BODY BlockClosure;

CASES ::= CASE | CASE CASES;

CASE ::= Case LITERALS Colon FUNCTION_DECLARATION_BODY Break EndSentence;

RETURN_STATEMENT ::= Return EXPRESSION EndSentence;

BREAK_STATEMENT ::= Break EndSentence;
